# 파이썬 인터프리터

## 개발환경

1. IDE(intergrated Development Environment)

- 통합개발환경
- 여러가지를 한 프로그램으로 사용
- 개발 시 1)인터프리터 2)에디터 3)여러 유틸들이 필요

2. Jupyter

- .ipynb 확장자
- 셀 단위로 실행하기에 명령어들을 독립된 형태로 구성해서 따로 실행 가능



## 언어 실행에 따른 종류

1. 컴파일 언어

- C,C++,Java,...
- 숫자만 입력 받음
  - 바이너리(이진수), 0과 1로 이루어진 값만 처리
  - 문자로 작성된 소스코드(파일)는 기계어로 변경 필수 = **컴파일(번역)**

2. 인터프리터 언어

- 파이썬, 자바스크립트, R, 루비, PHP,...
- Line By Line
  - 소스코드를 읽어들여 명령어마다 기계어로 그때그때 번역->컴파일 과정이 필요가 없음
  - 이 과정을 인터프리터가 처리함



-  REPL(Read, Evaluation, Print, Loop)
  - 인터프리터는 REPL 과정을 따라서 동작함
  - **Read : **입력된 명령어 읽음 
    - 이 과정에서 파이썬 인터프리터가 번역을 함 (*기계어*)
    - 문자로 된 명령어 -> 숫자(기계어/binary)로 변환
  - **Evaluation** : 명령어 실행
  - **Print** : 명령어 실행 결과를 돌려줌
  - **Loop** : 이 과정을 계속 반복
- 모든 파이썬 명령들은 인터프리터에서 실행됨
- 주피터는 일반적인 개발환경과 인터프리터의 중간 환경 제공

```python
1+1
print(1+1) # 이 두 명령어는 엄연히 다름
```



## 자료의 타입

- **자료** : 프로그래밍(코딩)을 하는 대상
  - 자료 형태 -> `문자, 숫자` but 전부 숫자로 표현 가능
- 파이썬의 타입 ->**숫자(정수, 실수)**
  - 자료를 구성하는 가장 기본적인 `최소 단위`



### 숫자

- 정수(integer/int), 실수(float), 불리언(boolean/bool) 

#### 정수

- *int*로 표현, `음수,0 , 양수`
- 정수는 크기를 가짐(4byte)
- 파이썬은 정수 표현에 크기 제한이 없음. but 속도는 느려질 수 있음 ㅋ

```python
type(10) # 이런 식으로 타입 확인이 가능
type(-0)
```

결과값 : int

#### 실수(float)

- *부동소수점 방식*(움직이는 소수점 방식)
  - floating, 부유한다! => 소수점의 위치가 계속 바뀐다는 의미
  - 소수점이 앞에 위치하면, 수의 표현은 작아져도 정밀한 수 표현
  - 소수점이 뒤에 위치하면, 큰 수 표현이 가능하지만 정밀도는 낮아짐

- 실수형태를 정확하게 처리는 불가능
- 항상 오차 발생, 근사된 값으로 표현됨

```python
type(10.12)
type(10.)
```

결과값: float

#### 불리언(bool)

- 참, 거짓(True, False)
- True=1, False=0

```python
type(True)
```

결과값 : bool



### 문자열

- 문자 : 단일 문자 / 문자열 : 단일 문자의 집합
- 문자열 표시 : '(작은따옴표),"(큰따옴표),'''/''''(멀티라인)

```python
'''Hello
python'''  #결과값 : 'Hello\npython'

"""Hello
Python"""  #결과값 : 'Hello\nPython'

'Hello \
Python'    #결과값 : 'Hello Python'

print('Hello') : print('Python')
# 결과값 : Hello
#		  Python
 
```

#### 문자열 처리 방법

- 숫자만 처리가 가능하기에 문자에 해당되는 숫자를 정의함
- 영문 대/소문자, 숫자, 특수문자에 대응하는 유일한 숫자 테이블 = **아스키 코드**
  - 128개의 문자에 대한 숫자 테이블
  - 문자 -> 숫자(인코딩), 숫자->문자(디코딩)
  - 한글은 사용 불가능, 그 대신 새로운 문자 인코딩 셋을 만듦
    - UTF-8, CP949, EUC-KR
    - 파이썬은 기본 UTF-8을 기본 인코딩 셋으로 사용
    - 한글 윈도우즈는 EUC-KR 사용

#### 엔터와 공백(눈에 보이지 않는 것)

- 엔터
  - CR(Carriage Return) : 해당 라인의 가장 앞으로 이동
  - LF(Line Feed) : 종이를 말아 올리는 작업
    - 요즘은 LF로만 표현하는 추세
    - 윈도우즈는 둘다 사용, 리눅스는 LF만 사용
- 공백, 빈 문자 모두 다른 문자!

```python
''  #빈문자
' ' #공백
```

```python
print(10==0x0a)  #True
print(0x0a==0x0A)#True, 숫자는 문자가 아니기 때문에 대/소 구분 안함
```

```python
'a'>'A' # True, 아스키 코드 값으로 비교
```

#### 문자열 이스케이프

- 문자 사용 시 충돌 발생 => ',"
- 아무런 의미 없는 문자인데, 특별한 의미를 부여함 => LF(0x0a, \n)
- 탈출하고자 하는 문자 앞에 '\\'를 붙여줌 -> 원래의 문자 의미가 사라짐

경로 표현하는 경우

- 역슬래시 사용 -> 디스크 상에서 파일의 위치를 문자열로 표현 시.



**엔터, 탭, 벡스페이스 표현하고 싶을 때**

| 문자 | 의미             |
| ---- | ---------------- |
| \n   | 뉴라인(LF), 엔터 |
| \x0a | 뉴라인, 엔터     |
| \b   | 백스페이스       |
| \t   | 탭               |
| \x09 | 탭               |



## 연산자

- 사칙연산(+,-,*,/)
  - 지수연산(**),몫연산(//),나머지 연산(%)
- 불리언 연산자(and, or, not)
- 비교 연산자
  - =는 할당 연산자로 이용하고 있기 때문에
  - ==, !=, >, <, >=, <= 사용

### 사칙연산

- 피연산자의 타입에 따라 결과값 달라질 수 있음

```python
'1' * 10 # '1111111111'
```

### 논리연산

- and ,or, not
- 명제들 간의 연산 결과를 논리적으로 표현
- 우선순위 `NOT > AND > OR`

### 타입변환

- str(x) : x를 문자열로 변환한 결과를 반환
- int(X) : 실수 또는 문자열 x에 대해 정수로 변환한 결과를 반환
- float(x) : 정수 또는 문자열에 대해 실수로 변환한 결과를 반환
- bool(X) : 모든 타입을 참 or 거짓으로 변환된 값을 반환

```python
print( round( 10.555)) # 반올림
```

불리언 타입 변환 시

- 빈 문자, 빈 객체, 0은 무조건 거짓
- 그 외의 것들은 무조건 참



## 메모리

- RAM(Random Acces Memory), `주기억장치`
- 하드디스크(HDD),SSD,USB 등은 `보조기억 장치`
  - 어떤 자료가 보조기억장치에 있을 때 `파일`이라고 부름
- 주기억장치
  - 프로그램 실행 중에는 반드시 메모리에 존재
  - 다루려는 자료들 또한 메모리에 있어야 함
  - 메모리 : 실행 중인 프로그램(프로세스)에서 자료를 저장할 수 있는 공간
  - 명령어 실행 결과, 보조기억장치의 파일로부터 읽어들인 내용들을 메모리 어딘가에 저장해두고 계속 꺼내서 씀  => **변수**

#### 주소(address)

- 메모리 상에서 값이 저장된 위치
- 변수를 주소 기준으로 식별
- 비트 형태로 저장, 1바이트마다 번호 부여. 첫번째 바이트의 주소는 0
- 일반적으로 16진수 형태의 표현을 많이 사용

#### 변수(Variable)

- 메모리에 값 저장해두고 계속 다시 꺼내서 사용 or 값을 업데이트 하는 용도로 사용하기 위한 이름
- 다시 꺼내서 사용하기 위해서는 저장된 위치를 알고 있어야 함
  - 주소는 숫자로 표현됨, 저장값 너무 크고 많음 등등으로 전부 기억이 불가능
  - 숫자 대신 문자로 대체해서 사용하기도,
  - 그래서 문자인 변수로 이름을 설정하는 것!
- 한 번 할당된 변수는 프로세스 종료까지 계속 유지

```python
mem=10
hex(id(mem)) # id:주소, hex:16진수 함수
```

#### swap

- 두 변수의 값 교환

```python
a=10
b=20
a,b = b,a   
```

##### 동적 바인딩

```python
a=10
b=20
a=b
print(hex(id(a)))
print(hex(id(b))) # a, b 모두 주소 동일
```



### 시퀀스 타입

- 기본 타입(숫자, 문자열)으로 이루어진 여러 자료들을 하나의 자료형으로 다루기 위한 방법
- `자료구조`의 한 종류 : 여러 개의 자료를 관리하는 방법
- 시퀀스 타입 종류
  - 리스트
    - 다른 언어의 배열과 같은 개념
    - `선형자료구조`
  - 튜플(tuple)
    - 튜플 내의 자료값을 변경할 수 없음
    - 리스트는 변경 가능
  - 레인지(range)
    - 수열 생성

#### 튜플(tuple) 

- 대표적인 불가변형 타입
- 자료들의 값 바꿀 수 없음
- 문자열이 튜플
- 원소가 하나 이상 존재해야 함.
- 콤마가 있는 것은 연속된 자료의 종류라고 판단

```python
arr=(1,)
print(type(arr)) # <class 'tuple'>
print(arr)       # (1,)
```

##### 공통 연산자

- 가변형 타입과 불가면형 타입 모두 동일

```python
arr=(10,20,30,40,50)

print(10 in arr)   #True
print(100 in arr)  #False

print(10 not in arr) #False
print(100 not in arr)#True
```

덧셈과 곱셈 연산 가능 -> 리스트도 가능

```python
arr + (1oo, 200, 300) # (10,20,30,40,50,100,200,300)

ar * 3 
```

*but, 원본은 변하지 않음*

###### 인덱싱과 슬라이스

- 파이썬의 시퀀스 타입은 자동으로 인덱스가 생성됨
  - 0부터 1씩 증가 자동 번호 매겨짐
  - 튜플(리스트)의 첫번째 원소 인덱스는 0
- 슬라이스는 시퀀스 내에서 원하는 범위 요소 선택

```python
print(arr[0]) #10
```

- `Index Out of Range` (주어진 시퀀스 타입의 범위를 벗어나느 참조)

``` python
print(arr[5])  #error남
```

```python
len(arr)  # 5
```

**음수 인덱스**도 자동 생성됨, -1부터 순차적으로 1씩 감소

*슬라이스*

```python
s[시작인덱스 : 끝인덱스: 증가수]
```

```python
arr[1:4] # (20,30,40)
```

##### 문자열

- 시퀀스 타입의 한 종류, 튜플의 종류
- 튜플의 속성 + 문자열의 속성

```python
string ='hello'
print(string[0])    #h
print(string[::-1]) #olleh
```

#### 리스트(list)

- 파이썬에서 가장 많이 사용, 다른 언어에선 `배열`
- 가장 기본적인 자료구조 형태

##### 공통 연산자

=튜플

##### 가변 연산자

```python
print(arr)
arr[0] =1
print(arr)  # [1,20,30,40]
```

###### append Vs. extend Vs. insert

| 명령어 | 내용                                        | 결과값                                                       |
| ------ | ------------------------------------------- | ------------------------------------------------------------ |
| append | 리스트 가장 마지막에 원소 추가, 한개        | print(arr.append(50)) =None                                  |
| extend | 원소 여러개를 리스트 마지막에 추가하는 경우 | print(arr.extend([50,60,70]))=None                           |
| insert | 리스트 중간에 원하는 위치에 원소 삽입       | arr.insert(2,25)=[10,20,25,30,40,50]<br />print(arr.insert(2,25))=None |

#### range

- 범위 내의 수열 생성, 정수만 가능

```python
# range(start, end)
range(1,10)  #1,2,3,4,5,6,7,8,9
list(range(1,10)) # [1,2,3,4,5,6,7,8,9]

print(list(range(0,10,2))) # [0,2,4,6,8] 짝수 수열
print(list(range(1,10,2))) # [1,3,5,7,9] 홀수 수열
```

### 매핑형 타입

- 딕셔너리, `해시 자료구조`

```python
{key:value,key:value, ...}
```

- key를 직접 정의할 수 있음=>인덱스가 자동으로 설정되지 않기 때문, 숫자가 아니어도 됨

```python
hash={}
hash['first']=10
hash # {'first : 10'}
hash['second'] = 20
hash # {'first':10, 'second' :20}
```

- 키는 수정할 수 있음, but 키의 값은 수정할 수 있음

```python
del hash['first'] #키 값 삭제
```

```python
# 키 리스트만 따로 확인할 수 있습니다. 
print( hash.keys() ) #dict_keys(['second','first'])

# 값만 따로 확인할 수 있습니다. 
print( hash.values() ) #dict_values([20,10])

# 키와 값을 한쌍의 튜플로 하는 리스트를 얻을 수 있습니다. 
print( hash.items() ) # dict_items([('second',20),('first',10)])
```

### 복사

- 얕은 복사, 깊은 복사

*얕은 복사*

```
arr=[10,20,30]
other = arr # 메모리 복사
print(hex(id(arr)))
print(hex(id(other))) # 두 메모리의 위치는 동일
```

- 변수 이름은 다르지만 동일한 주소를 나타냄
  - 즉, 두 변수는 같은 변수가 됨
  - 값이 복사되지는 않고 주소만 서로 공유함, 같은 메모리를 참조하는 변수가 2개가 된 셈
- 파이썬의 기본 복사는 얕은 복사



*깊은 복사*

- deepcopy를 이용해야 함, 그 외에는 전부 얕은 복사
- 불가변형에 대해선 값을 굳이 복사하진 않음

```python
arr2D=[
[1,2,3],
[4,5,6]
]

from copy import deepcopy
other = deepcopy(arr2D)

print(hex(id(arr2D)))
print(hex(id(other))) # 둘의 주소가 다름

print(hex(id(arr2D[0])))
print(hex(id(other[0]))) # 둘의 주소 다름
```

```python
arr=[1,2,3,4]
other=deepcopy(arr)

print(hex(id(arr)))
print(hex(id(other)))  # 둘 주소값 다름
```



# 제어문과 함수

## 제어문

- `분기문, 반복문`을 사용해서 전체 코드의 실행 흐름 제어
- 알고리즘이란, 제어문을 다루는 방법이라고 볼 수 있음

### 분기문(조건문)

- `if`
  - 다른 언어에서는  `switch-case`문법이 존재하지만 굳이 사용 잘 안함

```python
if 명제:
[들여쓰기] 명령어들 ..
```

- 빈 블록 작성하고 싶다면, pass 사용. 예외가 발생하는 것을막아줌

```python
if 1 in mem:
	pass
```

- 다중조건은 elif 도 추가해서 사용

  

### 반복문

#### while

- while은 명제를 거짓이 될 때까지 여러번 검사함
- continue 명령 이후의 명령어들은 실행 안됨

#### for

- 이터레이블 타입에 특화되어 있음
  - 이터레이블이란? 반복 가능한 모든 객체
  - 첫 번째 원소부터 마지막 원소까지 순차적으로 접근 가능 시 이터레이블이라고 함
  - 시퀀스 타입이 이터레이블
    - 리스트, 튜플, 문자열,...

```python
for 변수 in 이터레이블:
	#for 블록
```

- 이터레이블의 원소 개수만큼 반복함
- 반복하면서 매 회차마다 이터레이블 내의 원소들을 첫 원소부터 차례대로 변수를 넣어주면서 동작

##### range와 함께 사용

```python
for i in range(5):
    print(i)
```

0

1

2

3

4

##### List Comprehension

- 수학적으로 집합 정의

```python
# 한 줄로 집합 정의
[x for x in range(1,11)]
# [1,2,3,4,5,6,7,8,9,10]
[x*2 for x in range(1,11)]
# [2,4,6,8,10,12,14,16,18,20]
```

- 초기화된 리스트가 필요한 경우
  - 변수가 의미가 없는 경우에는, 변수를 사용하지 않는다는 의미로 ` _`를 사용

```python
[0 for _ in range(10)]
#[0,0,0,0,0,0,0,0,0,0]
[0] *10
#[0,0,0,0,0,0,0,0,0,0]
```



## 함수(function)

- 여러 명령어들의 집합
- 중복되는 명령어를 줄이고, 코드의 양이 줄기 때문에 효율적으로 관리가 가능함

```python
def 함수이름(파라미터, 파라미터, ...):
    # 함수 블록
```

- parameter(파라미터/매개변수), argument(아규먼트/인자)
- 함수를 실행하는데 필요한 입력 존재 시, 파라미터를 통해 전달

### 가변인자( 패킹, packing)

- 입력값의 개수가 정해저 있지 않은 경우
  - 몇 개의 값을 전달받을지,전달할지 알 수 없는 경우

```python
def function(*arg):
    print(args)
```

- 입력이 몇개가 되든 상관없이 전달 가능
- 튜플로 묶어서 전달
  - 여러개의 입력을 하나의 `튜플`로 묶어서 전달
- 변수 이름과 함께 전달
  - 변수 이름을 키로 하는 `딕셔너리` 형태로 묶어서 전달

```python
def function(**kwargs):
    print(kwargs)
    
function(a=1, b=2, c=3, d=4) 
#{'a':1, 'b':2, 'c':3, 'd':4}
```

두 가지 방법 함께 사용

```python
def function(*args, **kwargs):
    print(args, kwargs)
    
    
function(1,2,3,4,5,6,7,a=1,b=2,c=3)
# (1,2,3,4,5,6,7) {'a':1, 'b':2, 'c':3}
```

반대도 가능 -> `unpacking`

```python
def function(a,b,c):
    print(a,b,c)
    
    
arr=[10,20,30]
function(*arr)  # 10 20 30
```

### 변환이 있는 함수

- 실행결과를 돌려주는 경우
- return
  - Caller 에게 돌려줌
  - 함수 내에서만 사용 가능
  - return 명령이 실행되면, 함수는 바로 종료됨

```python
def no_return(a, b):
  print( a + b )

print( no_return(10, 20) )
#30
#None
```

## 함수 호출 구조

### 지역변수(Local Variable)

- 변수는 메모리의 주소 대신 사용하는 이름이라고 생각하면 됨
  - 글로벌 메모리
  - 로컬 메모리(함수가 사용하는 메모리)
- 함수가 실행되는 동안에만 유지되는 변수

## 함수 종류

### 재귀함수

- 자기 자신을 호출하는 함수
- 오류 발생하기 쉽기 때문에 최대 `재귀호출` 개수를 정해놓고 그 이상은 호출되지 않도록 방지 - 파이썬은 1000개

```python
def recursive():
    print('무한히 반복하는 형태')
    recursive()
    
recursive() # 트리거
```

### 익명함수

- 람다(Lambda)를 이용
- 함수의 이름이 없기 때문에 익명함수로 불림

```
lambda 파라미터 : 명령어
```

- 한 라인에 정의 가능한 간단한형태를 사용할 때 유용함

```python
(lambda a,b : a+b)(10,20)
# 30
```

### 함수형 문법

1. 절차(Procedure)형 프로그래밍

   - 부프로그램의 의미로 해석 ->함수

   - 소스코드를 함수 단위로 해석

1. 객체지향 프로그래밍

   - 함수 단위로 소스코드 작성 시 해결 안되는 경우

   - 클래스라는 개념 도입

1. 함수형 프로그래밍
   - 반복문 없음, 코드를 작성하는 완벽히 새로운 방법

- map, filter,reduce와같은 함수 제공

```python
x = [1.0, 2.0, 3.0, 4.0]
list( map(int, x) )
# [1,2,3,4]

x = [1, 2, 3, 4]
list( map(lambda x: 2 * x, x) )
# [2, 4, 6, 8]
```



# 객체지향 프로그래밍
